# 高级排序

## 希尔排序
希尔排序不像快速排序和其他时间复杂度为O(N*logN)的排序算法那么快,因此对于非常大的文件排序，希尔排序不是最优的选择。

按时，希尔排序比选择排序和插入排序这种时间复杂度O(N2)的排序算法还是要快得多，并且它非常容易实现:希尔排序算法的代码既短又简单。

希尔排序是基于插入排序


## 划分
划分是快速排序的根本机制。
划分数据就是把数据分为两组，使所有关键字大于特定值的数据项在一组，使所有关键字小于特定值的数据项在另一组。

### 划分算法
划分算法由两个指针开始工作，两个指针分别指向数组的两头。

### 划分算法的效率
划分算法的运行时间为O(N)


## 快速排序

## 小结
- 希尔排序将增量应用到插入排序，然后逐渐缩小增量
- n-增量排序表示每隔n个元素进行排序
- 被称为间隔序列或者间距序列的数列决定了希尔排序的排序间隔
- 常用的间隔序列是由递归表达式h=3*h+1生成的，h的初始值为1
- 一个容纳了1000个数据项的数组，对它进行希尔排序可以是间隔序列为364，,121,40,13,4，最后是1的增量排序
- 希尔排序很难分析，但是它运行的时间复杂度为O(N*(logN)2)。这比时间复杂度为O(N2)的排序算要快，例如比插入排序快，但是比时间复杂度为O(N*logN)的算法慢,例如比快速排序慢
- 划分数组就是把数组分为两个子数组，在一组中的所有的数据项关键字都小于指定的值，而在另一组中所有数据项关键字的值则大于或等于给定值
- 枢纽是在划分的过程中确定数据项应该放在哪一组的值。小于枢纽的数据项都放在左边一个组；而大于枢纽的数据项都放在右边一组
- 在划分算法中，在各自的while循环中的两个数组下标的指针，分别从数组的两端开始，相向移动，查找需要交换的数据项
- 当一个数组下标指针找到一个需要交互的数据项时，它的while循环中止
- 当两个while循环都终止时，交换这两个数据项
- 当两个while循环都终止时，并且两个子数组的下标指针相遇或者交错，则划分过程结束
- 划分操作有线性的时间复杂度O(N),做N+1或N+2次的比较以及少于N/2次的交换
- 划分算法的内部while循环需要额外的检测，以防止数组下标越界
- 快速排序划分一个数组，然后递归调用自身，对划分得到的两个子数组进行快速排序
- 只含有一个数据项的子数组定为已经有序，这一点可以作为快速排序算法的基值(终止)条件
- 快速排序算法划分时的枢纽是一个特定数据项关键字的值，这个数据项称为pivot(枢纽)
- 在快速排序的简单版本中，总是由子数组的最右端的数据项作为枢纽
- 划分的过程中枢纽总是放在划分子数组的右界，它不包含在划分过程中
- 划分之后枢纽也换位，被放在两个划分子数组之间。这就是枢纽的最终排序位置
- 快速排序的简单版本，对已经有序(或者逆序)的数据项排序的执行效率只有O(N2)
- 更高级的快速排序版本中，枢纽是子数组中第一个、最后一个以及中间一个数据项的中值，这称为"三数据项取中"划分
- 在三数据项中取中划分中，在对左端、中间以及右端的数据项取中值的同时对它们进行排序
- 这个排序算法消除了划分算法内部while循环中对数据越界的检测
- 快速排序算法的时间复杂度为O(N*log2N)(除了用剪刀的快速排序版本对已有序数据项排序的情况)
- 子数组小于一定容量(切割界限，cutoff)时用另一种方法来排序，而不用快速排序
- 通常用插入排序对小于切割界限的子数组排序
- 在快速排序已经对大于切割界限的子数组排完序之后，插入排序也可用于整个的数组
- 基数排序的时间复杂度和快速排序相同，只是它需要两倍的存储空间
